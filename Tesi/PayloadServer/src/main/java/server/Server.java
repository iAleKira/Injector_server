package server;

import java.util.Iterator;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

import org.cornutum.regexpgen.RandomGen;
import org.cornutum.regexpgen.random.RandomBoundsGen;

import injector.InjectionHandler;

import java.io.*;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;

/**
 * @author Alessandro Bonfiglio.
 * 
 * This class hosts the main method and therefore how the server, which
 * is listening on certain ports for an incoming connection, will
 * interact with its clients. The response given by the the server is
 * defined in the {@link generateResponse} method.
 * 
 * The Server class makes use of different objects: 
 * - {@link InjectionHandler} injector: which identifies the capture group of the string
 * injectable by a payload. 
 * - {@link ResponseGenerator} responder: which generates a response to return. 
 * The server also makes use of: 
 * - Selector selector: multiplexor to open multiple connections on the same port. 
 * - String payload: string to inject in the response.
 * 
 * @param args: no parameters are allowed.
 * 
 * 
 * @throws IOException: The server has restrictions. The path in
 * which the server will look for files is:
 * TextFiles/InjectableProbes/toInject/. If the server is not
 * launched from the same directory as TextFiles then there will be troubles tracking
 * the files containing the payloads in the file system. So to
 * avoid this the user is restricted to a fixed path with an
 * IOException.
 * 
 * This class setups a Selector, used to open more connections 
 * on the same port and select the appropriate client to respond to, and a
 * SocketServerChannel to listen for incoming connections on all
 * ports contained in the map at the same time. The listening ports are those
 * described in the {@link fillMap} method from class
 * {@link Database}. The iteration goes through the keys of the
 * selector: each time a connection is made on port x, the server
 * will reply with an answer suitable for port x.
 *
 * If the executable is launched from the correct directory and the
 * port it wants to listen to is supported - that is it's in the
 * Map and there are its database files - then the program will
 * run: A string is extracted from the proper database file, it
 * then gets matched with a string generated by a RegulaxExpression
 * parser and the obtained new string is returned as output to the
 * client.
 * 
 * Example: if a client opens a connection on port 22, then the
 * ssh.txt file will be used, and a random line from that file is
 * extracted, injected and parsed so that the result matches the
 * extracted string and returned to the client.
 */
public class Server {
	private static String payloadPath;
	public static void main(String[] args) throws IOException {
		switch (args.length) {
		case 0:
			payloadPath = "Payloads//example_payloads.txt";
			break;
		case 1:
			payloadPath = args[0];
			break;
		default:
			System.err.println(
					"Cannot locate " + args[0] + ". Usage : ./Nif.jar inputFile.\nMake sure the path is in the same"
							+ " directory as the jar file.\nExample: ./Nif.jar Payloads//example_payloads.txt.");
			System.exit(1);
		}

		Map<Integer, String> map = new HashMap<Integer, String>();
		Database database = new Database(map);
		InjectionHandler injector = new InjectionHandler();
		ResponseGenerator responder = new ResponseGenerator();
		RandomGen random = new RandomBoundsGen();
		Selector selector = Selector.open();

		database.fillMap();
		Server.fixMap(map);
		
		try {
			for (int port : map.keySet()) {
				ServerSocketChannel serverChannel = ServerSocketChannel.open();
				serverChannel.configureBlocking(false);
				serverChannel.socket().bind(new InetSocketAddress(port));
				serverChannel.register(selector, SelectionKey.OP_ACCEPT);
			}

			System.out.println("Server listening on ports: " + map.keySet());

			while (selector.isOpen()) {
				selector.select();
				Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
				while (iterator.hasNext()) {
					SelectionKey selectedKey = iterator.next();

					if (selectedKey.isAcceptable()) {
						SocketChannel clientSocketChannel = ((ServerSocketChannel) selectedKey.channel()).accept();
						Socket clientSocket = clientSocketChannel.socket();

						String filePath = "TextFiles//injectableProbes//toInject//"
								+ map.get(clientSocket.getLocalPort()) + ".txt";
						try {
						BufferedReader fileToRead = new BufferedReader(new FileReader(filePath));
						BufferedReader payloadToRead = new BufferedReader(new FileReader(payloadPath));
						String payload = database.getRandomLineFromFile(payloadToRead, payloadPath);
						PrintWriter output = new PrintWriter(clientSocket.getOutputStream(), true);
						System.out.println("Client " + clientSocket.getInetAddress().getHostName() + " opened connection on local port:" 
						+ clientSocket.getLocalPort()+".");
						String toInject = database.getRandomLineFromFile(fileToRead, filePath);
						String answer = responder.generateResponse(toInject, injector, payload, random);

						System.out.println("Payload to deliver: " + payload);
						output.println(answer);
						System.out.println("Response delivered: " + answer);
						} catch (IOException ex){
							System.err.println("File is not present for service " + map.get(clientSocket.getLocalPort()));
							clientSocket.close();
						}
					}
				}
				selector.selectedKeys().clear();
			}
		} catch (IOException e) {
			System.out.println(
					"An error occurred when retrieving data from database.\nMake sure Nif.jar is launched in the same "
							+ "directory as well as "+ payloadPath + " and TextFiles.");
		}
	}
	
	/**
	 * This method iterates on every key in the map and clears the key from the map 
	 * if the corresponding file doesn't exist.
	 * 
	 * @param map - map we want to cleanup for not existent files.
	 */
	private static void fixMap(Map<Integer,String> map) {
		for (int key : new ArrayList<Integer>(map.keySet())) {
			File tempFile = new File("TextFiles//injectableProbes//toInject//"+ map.get(key) + ".txt");
			if (!tempFile.exists()) {
				map.remove(key);
			}
		}
	}
}